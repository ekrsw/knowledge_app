# KSAP „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ ÊäÄË°ì‰ªïÊßò

## üõ†Ô∏è ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØË©≥Á¥∞

### „Ç≥„Ç¢ÊäÄË°ì
```json
{
  "framework": {
    "nextjs": "15.5.3",
    "react": "19.1.0",
    "typescript": "^5.0.0"
  },
  "styling": {
    "tailwindcss": "^4.0.0",
    "@tailwindcss/postcss": "^4.0.0"
  },
  "development": {
    "eslint": "^9.0.0",
    "eslint-config-next": "15.5.3",
    "@eslint/eslintrc": "^3.0.0"
  },
  "additional": {
    "react-diff-viewer-continued": "^3.3.0",
    "clsx": "^2.1.0"
  }
}
```

### Next.js 15 Ë®≠ÂÆö
```typescript
// next.config.ts
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  // Turbopack for development
  experimental: {
    turbo: {
      rules: {
        '*.svg': {
          loaders: ['@svgr/webpack'],
          as: '*.js',
        },
      },
    },
  },

  // TypeScript configuration
  typescript: {
    tsconfigPath: './tsconfig.json',
  },

  // Environment variables
  env: {
    API_BASE_URL: process.env.API_BASE_URL || 'http://localhost:8000/api/v1',
    JWT_SECRET_KEY: process.env.JWT_SECRET_KEY || 'dev-secret-key',
  },

  // Build optimization
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },

  // Headers for security
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin',
          },
        ],
      },
    ];
  },
};

export default nextConfig;
```

### TypeScript Ë®≠ÂÆö
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@/components/*": ["./components/*"],
      "@/lib/*": ["./lib/*"],
      "@/hooks/*": ["./hooks/*"],
      "@/types/*": ["./types/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

## üèóÔ∏è Áä∂ÊÖãÁÆ°ÁêÜ„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£

### React Context „Éë„Çø„Éº„É≥
```typescript
// contexts/AuthContext.tsx
interface AuthContextType {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<{
    user: User | null;
    token: string | null;
    isLoading: boolean;
  }>({
    user: null,
    token: null,
    isLoading: true,
  });

  // JWTËá™ÂãïÊõ¥Êñ∞
  useEffect(() => {
    const token = localStorage.getItem('ksap_token');
    if (token) {
      validateAndRefreshToken(token);
    } else {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, []);

  const login = async (credentials: LoginCredentials) => {
    const response = await api.auth.login(credentials);
    const userData = await api.auth.getCurrentUser();

    setState({
      user: userData,
      token: response.access_token,
      isLoading: false,
    });

    localStorage.setItem('ksap_token', response.access_token);
    api.setToken(response.access_token);
  };

  const logout = async () => {
    await api.auth.logout();
    setState({ user: null, token: null, isLoading: false });
    localStorage.removeItem('ksap_token');
    api.clearToken();
  };

  return (
    <AuthContext.Provider value={{
      ...state,
      isAuthenticated: !!state.user && !!state.token,
      login,
      logout,
      refreshToken: () => validateAndRefreshToken(state.token),
    }}>
      {children}
    </AuthContext.Provider>
  );
}
```

### ÊâøË™ç„Ç≠„É•„ÉºÁÆ°ÁêÜ Context
```typescript
// contexts/ApprovalQueueContext.tsx
interface ApprovalQueueContextType {
  queue: RevisionWithNames[];
  currentIndex: number;
  loading: boolean;
  error: string | null;
  refresh: () => Promise<void>;
  navigateToNext: () => string | null;
  navigateToPrevious: () => string | null;
  markAsProcessed: (revisionId: string) => void;
}

export function ApprovalQueueProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<{
    queue: RevisionWithNames[];
    currentIndex: number;
    loading: boolean;
    error: string | null;
  }>({
    queue: [],
    currentIndex: 0,
    loading: true,
    error: null,
  });

  const refresh = async () => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      const queue = await api.approval.getApprovalQueue();
      setState(prev => ({ ...prev, queue, loading: false }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : '„Ç≠„É•„Éº„ÅÆÂèñÂæó„Å´Â§±Êïó',
      }));
    }
  };

  const navigateToNext = (): string | null => {
    const nextIndex = state.currentIndex + 1;
    if (nextIndex < state.queue.length) {
      setState(prev => ({ ...prev, currentIndex: nextIndex }));
      return state.queue[nextIndex].revision_id;
    }
    return null;
  };

  const navigateToPrevious = (): string | null => {
    const prevIndex = state.currentIndex - 1;
    if (prevIndex >= 0) {
      setState(prev => ({ ...prev, currentIndex: prevIndex }));
      return state.queue[prevIndex].revision_id;
    }
    return null;
  };

  const markAsProcessed = (revisionId: string) => {
    setState(prev => ({
      ...prev,
      queue: prev.queue.filter(item => item.revision_id !== revisionId),
    }));
  };

  return (
    <ApprovalQueueContext.Provider value={{
      ...state,
      refresh,
      navigateToNext,
      navigateToPrevious,
      markAsProcessed,
    }}>
      {children}
    </ApprovalQueueContext.Provider>
  );
}
```

## ‚ö° „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ

### „Ç≥„Éº„Éâ„Çπ„Éó„É™„ÉÉ„ÉÜ„Ç£„É≥„Ç∞
```typescript
// Dynamic imports for non-critical components
const AdminPanel = dynamic(() => import('@/components/admin/AdminPanel'), {
  ssr: false,
  loading: () => <LoadingSpinner />,
});

const DiffViewer = dynamic(() => import('@/components/approvals/DiffViewer'), {
  ssr: false,
  loading: () => <DiffSkeleton />,
});

// Route-level code splitting
const ProposalCreation = lazy(() => import('@/components/proposals/ProposalCreation'));
```

### „É°„É¢ÂåñÊà¶Áï•
```typescript
// hooks/useApprovalReview.ts (ÊúÄÈÅ©ÂåñÁâà)
export function useApprovalReview(revisionId: string) {
  // „Éá„Éº„Çø„ÅÆ„É°„É¢Âåñ
  const revisionData = useMemo(() => {
    return revisionCache.get(revisionId);
  }, [revisionId]);

  // APIÂëº„Å≥Âá∫„Åó„ÅÆÊúÄÈÅ©Âåñ
  const { data: revision, error: revisionError } = useSWR(
    `/revisions/${revisionId}`,
    () => api.approval.getRevision(revisionId),
    {
      revalidateOnFocus: false,
      dedupingInterval: 5000,
    }
  );

  // Â∑ÆÂàÜ„Éá„Éº„Çø„ÅÆ‰∏¶ÂàóÂèñÂæó
  const { data: diff, error: diffError } = useSWR(
    `/diffs/${revisionId}`,
    () => api.approval.getRevisionDiff(revisionId),
    {
      revalidateOnFocus: false,
      dedupingInterval: 5000,
    }
  );

  // Âà§ÂÆöÈÄÅ‰ø°„ÅÆÊúÄÈÅ©Âåñ
  const submitDecision = useCallback(async (decision: ApprovalDecision) => {
    // Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞
    mutate(`/revisions/${revisionId}`,
      { ...revision, status: decision.action === 'approve' ? 'approved' : 'rejected' },
      false
    );

    try {
      await api.approval.submitDecision(revisionId, decision);
      // ÊàêÂäüÊôÇ„Å´„Ç≠„É•„Éº„ÇíÊõ¥Êñ∞
      mutate('/approvals/queue');
    } catch (error) {
      // „Ç®„É©„ÉºÊôÇ„Å´ÂÖÉ„ÅÆÁä∂ÊÖã„Å´Êàª„Åô
      mutate(`/revisions/${revisionId}`);
      throw error;
    }
  }, [revisionId, revision]);

  return {
    revision,
    diff,
    loading: !revision || !diff,
    error: revisionError || diffError,
    submitDecision,
  };
}
```

### ‰ªÆÊÉ≥„Çπ„ÇØ„É≠„Éº„É´ (Â§ßÈáè„Éá„Éº„ÇøÂØæÂøú)
```typescript
// components/approvals/VirtualizedQueue.tsx (Â∞ÜÊù•Êã°ÂºµÁî®)
import { FixedSizeList as List } from 'react-window';

interface VirtualizedQueueProps {
  items: RevisionWithNames[];
  onItemClick: (item: RevisionWithNames) => void;
}

export function VirtualizedQueue({ items, onItemClick }: VirtualizedQueueProps) {
  const Row = ({ index, style }: { index: number; style: CSSProperties }) => (
    <div style={style}>
      <QueueItem
        item={items[index]}
        onClick={() => onItemClick(items[index])}
      />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
}
```

## üö¶ „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Êà¶Áï•

### „Ç∞„É≠„Éº„Éê„É´„Ç®„É©„Éº„Éê„Ç¶„É≥„ÉÄ„É™„Éº
```typescript
// components/ErrorBoundary.tsx
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class GlobalErrorBoundary extends Component<
  PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error, errorInfo: null };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({ error, errorInfo });

    // „Ç®„É©„Éº„É¨„Éù„Éº„ÉÜ„Ç£„É≥„Ç∞ (Êú¨Áï™Áí∞Â¢É)
    if (process.env.NODE_ENV === 'production') {
      this.reportError(error, errorInfo);
    }
  }

  private reportError(error: Error, errorInfo: ErrorInfo) {
    // „Ç®„É©„Éº„É¨„Éù„Éº„ÉÜ„Ç£„É≥„Ç∞„Çµ„Éº„Éì„Çπ„Å´ÈÄÅ‰ø°
    console.error('Global Error:', error, errorInfo);
  }

  private handleRetry = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
          <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-6">
            <div className="flex items-center mb-4">
              <ExclamationTriangleIcon className="h-8 w-8 text-red-500 mr-3" />
              <h1 className="text-xl font-semibold text-gray-900">
                „Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº
              </h1>
            </div>

            <p className="text-gray-600 mb-6">
              ‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶ÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
            </p>

            <div className="flex space-x-4">
              <button
                onClick={this.handleRetry}
                className="flex-1 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
              >
                ÂÜçË©¶Ë°å
              </button>
              <button
                onClick={() => window.location.reload()}
                className="flex-1 bg-gray-600 text-white py-2 px-4 rounded-md hover:bg-gray-700"
              >
                „Éö„Éº„Ç∏ÂÜçË™≠„ÅøËæº„Åø
              </button>
            </div>

            {process.env.NODE_ENV === 'development' && (
              <details className="mt-6">
                <summary className="cursor-pointer text-sm text-gray-500">
                  „Ç®„É©„ÉºË©≥Á¥∞ (ÈñãÁô∫Áí∞Â¢É„ÅÆ„Åø)
                </summary>
                <pre className="mt-2 text-xs bg-gray-100 p-2 rounded overflow-auto">
                  {this.state.error?.stack}
                </pre>
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„ÉºÂá¶ÁêÜ
```typescript
// utils/error-handling.ts
export class ErrorHandler {
  static async handleApiError(error: unknown): Promise<never> {
    if (error instanceof ApiError) {
      switch (error.status) {
        case 401:
          // Ë™çË®º„Ç®„É©„Éº: „É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏„Å∏„É™„ÉÄ„Ç§„É¨„ÇØ„Éà
          window.location.href = '/login';
          throw error;

        case 403:
          // Ê®©Èôê„Ç®„É©„Éº: „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
          toast.error('„Åì„ÅÆÊìç‰Ωú„ÇíÂÆüË°å„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
          throw error;

        case 404:
          // „É™„ÇΩ„Éº„ÇπÊú™Áô∫Ë¶ã: ÈÅ©Âàá„Å™„Ç®„É©„Éº„Éö„Éº„Ç∏„Å∏
          throw new Error('Ë¶ÅÊ±Ç„Åï„Çå„Åü„É™„ÇΩ„Éº„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');

        case 422:
          // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥„Ç®„É©„Éº: „Éï„Ç£„Éº„É´„Éâ„Ç®„É©„Éº„ÇíË°®Á§∫
          if (error instanceof ValidationError) {
            this.handleValidationError(error.details);
          }
          throw error;

        case 500:
          // „Çµ„Éº„Éê„Éº„Ç®„É©„Éº: ‰∏ÄËà¨ÁöÑ„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏
          toast.error('„Çµ„Éº„Éê„Éº„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„Åè„Åó„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
          throw error;

        default:
          toast.error(error.message || '‰∏çÊòé„Å™„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
          throw error;
      }
    }

    // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„ÉºÁ≠â
    if (error instanceof TypeError && error.message.includes('fetch')) {
      toast.error('„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
      throw new Error('„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº');
    }

    // „Åù„ÅÆ‰ªñ„ÅÆ„Ç®„É©„Éº
    toast.error('‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
    throw error;
  }

  private static handleValidationError(details: any) {
    if (Array.isArray(details)) {
      details.forEach(detail => {
        toast.error(`${detail.field}: ${detail.message}`);
      });
    } else {
      toast.error('ÂÖ•ÂäõÂÜÖÂÆπ„Å´ÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô');
    }
  }
}
```

## üîê „Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂØæÁ≠ñ

### JWT „Çª„Ç≠„É•„É™„ÉÜ„Ç£
```typescript
// utils/jwt-security.ts
export class JWTManager {
  private static readonly TOKEN_KEY = 'ksap_token';
  private static readonly REFRESH_THRESHOLD = 5 * 60 * 1000; // 5ÂàÜÂâç

  static setToken(token: string): void {
    // HttpOnly cookie„Å∏„ÅÆ‰øùÂ≠ò („Çª„Ç≠„É•„Ç¢)
    document.cookie = `${this.TOKEN_KEY}=${token}; secure; samesite=strict; max-age=604800`; // 7Êó•

    // localStorage „ÅØ fallback „ÅÆ„Åø
    localStorage.setItem(this.TOKEN_KEY, token);
  }

  static getToken(): string | null {
    // CookieÂÑ™ÂÖà„ÄÅfallback „ÅßlocalStorage
    const cookieToken = this.getTokenFromCookie();
    if (cookieToken) return cookieToken;

    return localStorage.getItem(this.TOKEN_KEY);
  }

  static clearToken(): void {
    document.cookie = `${this.TOKEN_KEY}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
    localStorage.removeItem(this.TOKEN_KEY);
  }

  private static getTokenFromCookie(): string | null {
    const cookies = document.cookie.split(';');
    for (const cookie of cookies) {
      const [name, value] = cookie.trim().split('=');
      if (name === this.TOKEN_KEY) {
        return value;
      }
    }
    return null;
  }

  static isTokenExpiringSoon(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const exp = payload.exp * 1000; // Convert to milliseconds
      return Date.now() + this.REFRESH_THRESHOLD > exp;
    } catch {
      return true; // Invalid token
    }
  }

  // XSSÂØæÁ≠ñ: scriptÂÆüË°åÂâç„ÅÆtokenÊ§úË®º
  static validateTokenIntegrity(token: string): boolean {
    const parts = token.split('.');
    if (parts.length !== 3) return false;

    try {
      const payload = JSON.parse(atob(parts[1]));
      return typeof payload.sub === 'string' && typeof payload.exp === 'number';
    } catch {
      return false;
    }
  }
}
```

### CSRFÂØæÁ≠ñ
```typescript
// utils/csrf-protection.ts
export class CSRFProtection {
  private static readonly CSRF_TOKEN_KEY = 'ksap_csrf_token';

  static generateCSRFToken(): string {
    const token = crypto.randomUUID();
    sessionStorage.setItem(this.CSRF_TOKEN_KEY, token);
    return token;
  }

  static getCSRFToken(): string | null {
    return sessionStorage.getItem(this.CSRF_TOKEN_KEY);
  }

  static validateCSRFToken(receivedToken: string): boolean {
    const storedToken = this.getCSRFToken();
    return storedToken === receivedToken;
  }

  // API„É™„ÇØ„Ç®„Çπ„Éà„Å´CSRF„Éà„Éº„ÇØ„É≥„ÇíËá™Âãï‰ªò‰∏é
  static addCSRFHeader(headers: HeadersInit = {}): HeadersInit {
    const token = this.getCSRFToken();
    if (token) {
      return {
        ...headers,
        'X-CSRF-Token': token,
      };
    }
    return headers;
  }
}
```

## üß™ „ÉÜ„Çπ„ÉàÊà¶Áï•

### Unit Testing (Jest + React Testing Library)
```typescript
// __tests__/components/ApprovalActions.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ApprovalActions } from '@/components/approvals/ApprovalActions';

const mockOnDecision = jest.fn();

describe('ApprovalActions', () => {
  beforeEach(() => {
    mockOnDecision.mockClear();
  });

  it('should render all action buttons', () => {
    render(
      <ApprovalActions
        revisionId="test-id"
        onDecision={mockOnDecision}
      />
    );

    expect(screen.getByRole('button', { name: /ÊâøË™ç/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /Âç¥‰∏ã/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /Â§âÊõ¥Ë¶ÅÊ±Ç/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /‰øùÁïô/i })).toBeInTheDocument();
  });

  it('should call onDecision with correct parameters when approve button is clicked', async () => {
    render(
      <ApprovalActions
        revisionId="test-id"
        onDecision={mockOnDecision}
      />
    );

    const approveButton = screen.getByRole('button', { name: /ÊâøË™ç/i });
    fireEvent.click(approveButton);

    await waitFor(() => {
      expect(mockOnDecision).toHaveBeenCalledWith({
        action: 'approve',
        comment: undefined
      });
    });
  });

  it('should include comment when provided', async () => {
    render(
      <ApprovalActions
        revisionId="test-id"
        onDecision={mockOnDecision}
      />
    );

    const commentInput = screen.getByRole('textbox', { name: /„Ç≥„É°„É≥„Éà/i });
    const approveButton = screen.getByRole('button', { name: /ÊâøË™ç/i });

    fireEvent.change(commentInput, { target: { value: '„ÉÜ„Çπ„Éà„Ç≥„É°„É≥„Éà' } });
    fireEvent.click(approveButton);

    await waitFor(() => {
      expect(mockOnDecision).toHaveBeenCalledWith({
        action: 'approve',
        comment: '„ÉÜ„Çπ„Éà„Ç≥„É°„É≥„Éà'
      });
    });
  });
});
```

### Integration Testing
```typescript
// __tests__/integration/approval-flow.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { server } from '__mocks__/server';
import { ApprovalReviewPage } from '@/app/approvals/review/[id]/page';

describe('Approval Flow Integration', () => {
  beforeAll(() => server.listen());
  afterEach(() => server.resetHandlers());
  afterAll(() => server.close());

  it('should complete full approval workflow', async () => {
    render(<ApprovalReviewPage params={{ id: 'test-revision-id' }} />);

    // „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÂæÖÊ©ü
    await waitFor(() => {
      expect(screen.getByText('„ÉÜ„Çπ„ÉàË®ò‰∫ã„Çø„Ç§„Éà„É´')).toBeInTheDocument();
    });

    // Â∑ÆÂàÜË°®Á§∫Á¢∫Ë™ç
    expect(screen.getByText('Â§âÊõ¥ÂÜÖÂÆπ')).toBeInTheDocument();

    // ÊâøË™çÂá¶ÁêÜ
    const approveButton = screen.getByRole('button', { name: /ÊâøË™ç/i });
    fireEvent.click(approveButton);

    // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏Á¢∫Ë™ç
    await waitFor(() => {
      expect(screen.getByText('Âà§ÂÆöÂÆå‰∫Ü')).toBeInTheDocument();
    });
  });
});
```

### Performance Testing
```typescript
// __tests__/performance/rendering.test.tsx
import { render } from '@testing-library/react';
import { performance } from 'perf_hooks';
import { ApprovalReviewPage } from '@/app/approvals/review/[id]/page';

describe('Performance Tests', () => {
  it('should render approval review page within acceptable time', async () => {
    const startTime = performance.now();

    render(<ApprovalReviewPage params={{ id: 'test-id' }} />);

    const endTime = performance.now();
    const renderTime = endTime - startTime;

    // 100ms‰ª•ÂÜÖ„Åß„ÅÆ„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÇíÊúüÂæÖ
    expect(renderTime).toBeLessThan(100);
  });

  it('should handle large diff data efficiently', async () => {
    const largeDiff = {
      revision_id: 'test',
      field_diffs: Array(1000).fill({
        field_name: 'test_field',
        field_label: '„ÉÜ„Çπ„Éà„Éï„Ç£„Éº„É´„Éâ',
        change_type: 'modified',
        old_value: 'old'.repeat(100),
        new_value: 'new'.repeat(100),
        is_critical: false,
      }),
      total_changes: 1000,
      critical_changes: 10,
      impact_level: 'high' as const,
    };

    const startTime = performance.now();

    render(<DiffViewer diff={largeDiff} />);

    const endTime = performance.now();
    const renderTime = endTime - startTime;

    // Â§ßÈáè„Éá„Éº„Çø„Åß„ÇÇ200ms‰ª•ÂÜÖ
    expect(renderTime).toBeLessThan(200);
  });
});
```

## üì¶ „Éì„É´„Éâ„Éª„Éá„Éó„É≠„Ç§Ë®≠ÂÆö

### Êú¨Áï™„Éì„É´„ÉâÊúÄÈÅ©Âåñ
```javascript
// next.config.js (Êú¨Áï™Áí∞Â¢É)
const nextConfig = {
  // BundleÂàÜÊûê
  analyzeBundle: process.env.ANALYZE === 'true',

  // ÂúßÁ∏ÆË®≠ÂÆö
  compress: true,

  // ÁîªÂÉèÊúÄÈÅ©Âåñ
  images: {
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 60,
  },

  // PWAË®≠ÂÆö (Â∞ÜÊù•Êã°Âºµ)
  pwa: {
    dest: 'public',
    disable: process.env.NODE_ENV === 'development',
  },

  // „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Éò„ÉÉ„ÉÄ„Éº
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          { key: 'X-Frame-Options', value: 'DENY' },
          { key: 'X-Content-Type-Options', value: 'nosniff' },
          { key: 'X-XSS-Protection', value: '1; mode=block' },
          {
            key: 'Content-Security-Policy',
            value: "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';"
          },
        ],
      },
    ];
  },
};
```

### Dockerfile (Êú¨Áï™„Éá„Éó„É≠„Ç§Áî®)
```dockerfile
# Multi-stage build for production
FROM node:20-alpine AS deps
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci --only=production

FROM node:20-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs
EXPOSE 3000
ENV PORT 3000

CMD ["node", "server.js"]
```